# 5.1 并行任务

## 5.1.1 Python中的并行计算

Python对并行计算提供的原生支持远非完美。CPython实现了GIL（Global Interpreter Lock），GIL是必需的，因为CPython的内存管理不是线程安全的。但它带来了另一个很严重的问题，即它会阻止多线程的CPython程序运行于多核之上。

放弃掉GIL，NumPy中的一些线性代数函数可运行于多核上，但仅限于通过特定的库编译的（如ATLAS、MKL等）NumPy。否则，一般会用多进程而非多线程实现并行计算。由于进程间并不共享内存空间，进程间通信是个问题，比如使用Python的multithreading模块。一个更强大也更复杂的选择是使用Message Passing Interface（MPI）。

IPython对于上述两种方案都表现良好，它提供了一个并行计算的通用框架。借助于负载均衡，独立的任务很容易分发至不同的核或机器。数据也可以在不同的引擎间传送，从而可实现复杂的分布式计算。

## 5.1.2 多核并行

IPython提供的并行计算功能很强大，也是高度自定义的，不过这里仅介绍其最基本者。实现多核并行需要如下几步：

* 加载几个IPython引擎（每核一个）
* 为每个引擎创建一个Client对象作为proxy
* 使用client执行任务，获得执行结果

这些任务可按同步或异步的方式执行。

### 启动引擎

```
# conda install ipyparallel

# start one engine per core
ipcluster start

# or specify the number
ipcluster start -n 2
```

如果首次使用，先安装[ipyparallel](https://github.com/ipython/ipyparallel)，除了ipcluster命令，还可以使用Notebook的Clusters。

### 创建Client实例

```
from ipyparallel import Client
rc = Client()

rc.ids
# [0, 1, 2, 3]
```

### 开始并行魔法

最简单的方法是使用%px魔法命令，它在引擎上执行一条Python命令。

```
%px sum(range(101))
Out[0:8]: 5050
Out[1:8]: 5050
Out[2:8]: 5050
Out[3:8]: 5050

# specify engine
%pxconfig --targets 1
Out[1:9]: 5050
```

%%px命令提供的类似功能。







